#include <string>
//#include <ctime>
//#include <stdlib.h>//atoi
#include <iostream>
#include <fstream>
//#include "signal.h"//Ctrl+C catch
#include "fast_md4.h"

using namespace std;

typedef unsigned char uint8_t;
//typedef unsigned int uint32_t;

size_t getHash(char szHash[], unsigned char hash[])
{
       unsigned int number;
       size_t nHashLen;

       if(((nHashLen = strlen(szHash)) % 2) != 0)
            return(0);

       for(size_t i = 0;i < nHashLen;i++) {
           if(isxdigit(szHash[i]) == 0)
              return(0);
       }

       nHashLen /= 2;

       for(size_t i = 0;i < nHashLen;i++) {
           sscanf(&szHash[i*2],"%2x",&number);
           hash[i] = (unsigned char)number;
       }
       return(nHashLen);
}

void dump(uint8_t *digest)
{
		for(int i = 0;i < 16;i++)
			printf("%02X",digest[i]);
}

typedef unsigned short uint16_t;

int main(int argc, char *argv[])
{
	if(argc!=3)
		exit(1);

	uint8_t K[128],K2[128];//was 16 - 128 should be big enough
	uint16_t uni_pwd[128]={0};

	uint8_t mscache_hash_array[25][16]={{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
		{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F },
	{ 0xA6, 0x04, 0x67, 0x77, 0xA8, 0xE0, 0x5F, 0x53, 0x7F, 0x4C, 0xA1, 0x47, 0x9C, 0x26, 0x73, 0x3F }};

	int sUsernameSize[]={666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666,666};

	char u_username_array[25][40];

	//open the hash list...
	ifstream hash_list(argv[1]);

	//check to ensure hash list opened correctly
	if(!hash_list.is_open())
	{
		cout<<"Error opening file \'"<<argv[1]<<"\'\n";
		exit(1);
	}

	char shash[33];//temporary array to store hash strings in
	int numhashes=0;
	while(!hash_list.eof())
	{
		//mscache hash buffer
		uint8_t mscache_hash[16];
		hash_list.getline(shash,33);//get each line of hash file
		if(numhashes==25)//make sure that no more than 25 hashes are loaded
		{
			cout << "more than 25 hashes not supported as of this release!\n";
			exit(1);
		}
		if(strlen(shash)!=32)
		{
			cout << "mscache hash is a 32-character hex string\n";
			exit(1);
		}
		//convert strings to binary...
		getHash(shash,mscache_hash);
		//and store them in their arrays
		for(int i=0;i<16;i++)
			mscache_hash_array[numhashes][i]=mscache_hash[i];
		numhashes++;//count loops
	}

	hash_list.close();

	//open username list...
	ifstream username_list(argv[2]);

	//check to ensure username list opened correctly
	if(!username_list.is_open())
	{
		cout<<"Error opening file \'"<<argv[2]<<"\'\n";
		exit(1);
	}

	string sUsername;//temporary array to store username strings in
	int numusers=0;
	while(getline(username_list,sUsername)){
		sUsernameSize[numusers]=sUsername.size();
		memset(u_username_array[numusers], 0, 40);
		// Convert username to unicode and lowercase it
		for (unsigned int i = 0; i < sUsername.size(); i++)
		{
			u_username_array[numusers][i*2] = tolower(sUsername[i]);
			u_username_array[numusers][i*2+1] = 0x00;
		}
		numusers++;
	}

	username_list.close();

	if(numusers!=numhashes)
	{
		cout << "number of usernames does not equal number of hashes!\n";
		cout << "usernames and hashes should be respective to one another.\n";
		exit(1);
	}

	string candidate_s;
	cout << "\n";
	//char candidate_a[9999];//nope, no passwords over 9999 chars. But really?

	while(getline(cin,candidate_s)){
		//convert the string to an array:
		for(unsigned int i=0;i<candidate_s.size();i++)
			uni_pwd[i]=candidate_s[i];
		fast_MD4((unsigned char*)uni_pwd,candidate_s.size()*2,K);
		//memcpy(K+16, u_username, sUsername.size()*2);
		//fast_MD4((unsigned char*)K,(sUsername.size()*2+16),(unsigned char*)K);
		//check it out to see if it works...
		/*if(!memcmp(mscachehash,K,16))
		{
			cout << "\nplaintext of ";
			dump(K);
			cout << " is " << candidate_s << "\n";
			exit(1);
		}*/
		for(int i=0;i<numhashes;i++)//for each hash in file...
		{
			memcpy(K+16, u_username_array[i], sUsernameSize[i]*2);
			fast_MD4((unsigned char*)K,(sUsernameSize[i]*2+16),(unsigned char*)K2);
			if(!memcmp(mscache_hash_array[i],K2,16))
			{
				cout << "plaintext of ";
				dump(K2);
				cout << " is " << candidate_s << "\n";
			}
		}
	}

return 0;
}